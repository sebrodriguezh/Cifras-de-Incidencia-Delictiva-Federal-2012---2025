<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reporte de Incidencia Delictiva - SESNSP M√©xico</title>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <!-- Custom CSS Files -->
    <link rel="stylesheet" href="css/main.css">
    <link rel="stylesheet" href="css/snapshots.css">
    <!-- Leaflet CSS para mapas -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
</head>
<body>
    <!-- Header Section -->
    <header class="main-header">
        <div class="header-content">
            <h1>An√°lisis de las cifras de incidencia delictiva federal </h1>
            <p class="subtitle">Datos del Secretariado Ejecutivo del Sistema Nacional de Seguridad P√∫blica</p>
            <p class="update-date">√öltima actualizaci√≥n: Agosto 2025</p>
        </div>
    </header>

    <!-- Main Content Container -->
    <main class="main-container">
        <!-- Overview section -->
        <section class="content-section">
            <h2>Estructura de la base de datos</h2>
            <p class="section-description">Overview de la base de datos original</p>

            <!-- Data Summary Cards -->
            <div class="data-overview">
                <div class="summary-card">
                    <div class="card-icon"></div>
                    <div class="card-content">
                        <h3>Total de registros</h3>
                        <p class="card-number" id="total-registros-original">Cargando...</p>
                        <p class="card-description">Registros delictivos incluidos</p>
                    </div>
                </div>
                
                <div class="summary-card">
                    <div class="card-icon"></div>
                    <div class="card-content">
                        <h3>Per√≠odo</h3>
                        <p class="card-number" id="periodo-original">Cargando...</p>
                        <p class="card-description">Rango temporal completo</p>
                    </div>
                </div>
                
                <div class="summary-card">
                    <div class="card-icon"></div>
                    <div class="card-content">
                        <h3>Estados</h3>
                        <p class="card-number" id="total-estados-original">Cargando...</p>
                        <p class="card-description">Entidades federativas incluidas</p>
                    </div>
                </div>
                
                <div class="summary-card">
                    <div class="card-icon"></div>
                    <div class="card-content">
                        <h3>Conceptos</h3>
                        <p class="card-number" id="conceptos-unicos-original">Cargando...</p>
                        <p class="card-description">Conceptos principales</p>
                    </div>
                </div>
            </div>
            <p class="section-description">Base de datos procesada para el resto del informe</p>
            <!-- Data Summary Cards - Base Procesada -->
            <div class="data-overview">
                <div class="summary-card">
                    <div class="card-icon"></div>
                    <div class="card-content">
                        <h3>Total de Registros</h3>
                        <p class="card-number" id="total-registros-procesados">Cargando...</p>
                        <p class="card-description">Registros delictivos procesados</p>
                    </div>
                </div>
                
                <div class="summary-card">
                    <div class="card-icon"></div>
                    <div class="card-content">
                        <h3>Per√≠odo</h3>
                        <p class="card-number" id="periodo-procesado">Cargando...</p>
                        <p class="card-description">Rango temporal filtrado</p>
                    </div>
                </div>
                
                <div class="summary-card">
                    <div class="card-icon"></div>
                    <div class="card-content">
                        <h3>Estados</h3>
                        <p class="card-number" id="total-estados-procesados">Cargando...</p>
                        <p class="card-description">Entidades federativas incluidas</p>
                    </div>
                </div>
                
                <div class="summary-card">
                    <div class="card-icon"></div>
                    <div class="card-content">
                        <h3>Conceptos</h3>
                        <p class="card-number" id="conceptos-unicos-procesados">Cargando...</p>
                        <p class="card-description">Conceptos principales</p>
                    </div>
                </div>
            </div>
            
            <!-- Database Preview Table - Solo Base Procesada -->
            <div class="database-preview">
                <h3>Vista previa de la base procesada</h3>
                <p class="preview-description">Primeras 10 filas de la base procesada - 'IDEFF_processed.csv'</p>
                <div class="table-container">
                    <table class="data-table" id="preview-table-procesados">
                        <thead>
                            <tr>
                                <th>Cargando...</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Cargando datos...</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </section>


        <!-- Nacional Section -->
        <section class="content-section">
            <h2>Secci√≥n: Nacional</h2>
            <p class="section-description">An√°lisis a nivel nacional</p>
            
            <!-- Gr√°fica 1 -->
            <div class="chart-container">
                <h2>Gr√°fica 1. Evoluci√≥n temporal de la incidencia delictiva del fuero federal por concepto (2019‚Äì2025)</h2>
                <p class="table-description">Datos reportados por el Secretariado Ejecutivo del Sistema Nacional de Seguridad P√∫blica, enero‚Äìjulio de cada a√±o</p>
                <div style="height: 500px; width: 100%;">
                    <canvas id="nationalChart"></canvas>
                </div>
            </div>
            <!-- Tabla de Datos de la Gr√°fica -->
            <div class="table-container">
                <h3>Tabla 1. Valores absolutos de incidencia delictiva del fuero federal por concepto (2019‚Äì2025)</h3>
                <p class="table-description">Valores agregados por concepto y a√±o (suma de todos los meses)</p>
                
                <table class="data-table" id="national-concept-table">
                    <thead>
                        <tr>
                            <th>Concepto</th>
                            <th>2019</th>
                            <th>2020</th>
                            <th>2021</th>
                            <th>2022</th>
                            <th>2023</th>
                            <th>2024</th>
                            <th>2025</th>
                            <th>Total</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Cargando datos...</td>
                            <td colspan="7">Espera...</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <!-- Tabla de cambios porcentuales de la Gr√°fica -->
            <div class="table-container">
                <h3>Tabla 1.1 Variaci√≥n porcentual en la incidencia delictiva del fuero federal por concepto (2019‚Äì2025)</h3>
                <p class="table-description">Cambios porcentuales con respecto al a√±o anterior (enero-julio)</p>
                
                <table class="data-table" id="percentage-changes-table">
                    <thead>
                        <tr>
                            <th>Concepto</th>
                            <th>2019</th>
                            <th>2020</th>
                            <th>2021</th>
                            <th>2022</th>
                            <th>2023</th>
                            <th>2024</th>
                            <th>2025</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Cargando datos...</td>
                            <td colspan="7">Espera...</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <!-- Gr√°fica 2 -->
            <div class="chart-container">
                <h2>Gr√°fica 2. Distribuci√≥n porcentual anual de la incidencia delictiva del fuero federal por concepto (2019‚Äì2025)</h2>
                <p class="table-description">Datos reportados por el Secretariado Ejecutivo del Sistema Nacional de Seguridad P√∫blica, enero‚Äìjulio de cada a√±o</p>
                <!-- Grid de 7 pie charts -->
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 50px; margin-top: 20px;">
                    <div style="height: 300px; width: 100%;">
                        <canvas id="pieChart2019"></canvas>
                </div>
                    <div style="height: 300px; width: 100%;">
                        <canvas id="pieChart2020"></canvas>
            </div>
                    <div style="height: 300px; width: 100%;">
                        <canvas id="pieChart2021"></canvas>
            </div>
                    <div style="height: 300px; width: 100%;">
                        <canvas id="pieChart2022"></canvas>
                    </div>
                    <div style="height: 300px; width: 100%;">
                        <canvas id="pieChart2023"></canvas>
                    </div>
                    <div style="height: 300px; width: 100%;">
                        <canvas id="pieChart2024"></canvas>
                    </div>
                    <div style="height: 300px; width: 100%;">
                        <canvas id="pieChart2025"></canvas>
                    </div>
                </div>
            </div>
            <!-- Gr√°fica 3 -->
            <div class="chart-container">
                <h2>Gr√°fica 3. Distribuci√≥n porcentual anual de la incidencia delictiva del fuero federal por tipo (2019‚Äì2025)</h2>
                <p class="table-description">Distribuci√≥n porcentual de tipos para el concepto seleccionado</p>
                
                <!-- Selector de Concepto -->
                <div class="concept-selector">
                    <label for="concept-select">Selecciona un concepto:</label>
                    <select id="concept-select">
                        <option value="">Cargando conceptos...</option>
                    </select>
                </div>
                
                <!-- Grid de 7 pie charts -->
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 30px; margin-top: 20px;">
                    <div style="height: 300px; width: 100%;">
                        <canvas id="typePieChart2019"></canvas>
                    </div>
                    <div style="height: 300px; width: 100%;">
                        <canvas id="typePieChart2020"></canvas>
                    </div>
                    <div style="height: 300px; width: 100%;">
                        <canvas id="typePieChart2021"></canvas>
                    </div>
                    <div style="height: 300px; width: 100%;">
                        <canvas id="typePieChart2022"></canvas>
                    </div>
                    <div style="height: 300px; width: 100%;">
                        <canvas id="typePieChart2023"></canvas>
                    </div>
                    <div style="height: 300px; width: 100%;">
                        <canvas id="typePieChart2024"></canvas>
                    </div>
                    <div style="height: 300px; width: 100%;">
                        <canvas id="typePieChart2025"></canvas>
                    </div>
                </div>
            </div>
            <!-- Tabla de datos de la gr√°fica 3-->
            <div class="table-container">
                <h3>Tabla 2. Valores absolutos de la incidencia delictiva del fuero federal por tipo (2019‚Äì2025)</h3>
                <p class="table-description">Valores absolutos por concepto y a√±o (suma de enero-julio)</p>
            </div>
            
            <!-- Tabla de cambios porcentuales de la Gr√°fica 3 -->
            <div class="table-container">
                <h3>Tabla 2.1. Variaci√≥n porcentual de la incidencia delictiva del fuero federal por tipos (2019‚Äì2025)</h3>
                <p class="table-description">Cambios porcentuales con respecto al a√±o anterior para cada tipo</p>
            </div>
            
            <!-- Gr√°fica 4: Mapa de distribuci√≥n por entidad -->
            <div class="chart-container">
                <h2>Gr√°fica 4. Distribuci√≥n por entidad federativa</h2>
                
                <!-- Selectores de concepto y a√±o -->
                <div class="map-selectors">
                    <div class="concept-selector">
                        <label for="map-concept-selector">Selecciona el concepto a visualizar:</label>
                        <select id="map-concept-selector">
                            <option value="">Cargando conceptos...</option>
                        </select>
                    </div>
                    
                    <div class="year-selector">
                        <label for="map-year-slider">Selecciona el a√±o: <span id="year-display">2019</span></label>
                        <input type="range" id="map-year-slider" min="2019" max="2025" value="2019" step="1">
                        <div class="year-labels">
                            <span>2019</span>
                            <span>2020</span>
                            <span>2021</span>
                            <span>2022</span>
                            <span>2023</span>
                            <span>2024</span>
                            <span>2025</span>
                        </div>
                    </div>
                </div>
                
                <div id="map" class="map-container"></div>
                

            </div>

        </section>

        <!-- Estatal Section -->
        <section class="content-section">
            <h2>Estatal</h2>
            <p class="section-description">An√°lisis estatal con evoluci√≥n de rankings</p>
            
            
            <!-- Placeholder for your content -->
            <div class="placeholder-content">
                <p>Tu contenido aqu√≠...</p>
            </div>
        </section>

        <!-- Snapshots Section -->
        <section class="content-section">
            <h2>Snapshots Temporales</h2>
            <p class="section-description">Vista r√°pida de la evoluci√≥n temporal</p>
            
            <!-- Placeholder for your content -->
            <div class="placeholder-content">
                <p>Tu contenido aqu√≠...</p>
            </div>
        </section>
    </main>

    <!-- JavaScript para cargar estad√≠sticas -->
         <!-- JavaScript para cargar estad√≠sticas -->
    <script>
        // Funci√≥n para cargar estad√≠sticas de la base ORIGINAL
        async function loadOriginalStats() {
            try {
                console.log('üîÑ Cargando estad√≠sticas de base original...');
                const response = await fetch('data/stats.json');
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const stats = await response.json();
                console.log('‚úÖ Estad√≠sticas originales cargadas:', stats);
                
                // Actualizar elementos de la base ORIGINAL
                if (stats.total_registros !== undefined) {
                    document.getElementById('total-registros-original').textContent = stats.total_registros.toLocaleString();
                }
                
                if (stats.fecha_minima && stats.fecha_maxima) {
                    document.getElementById('periodo-original').textContent = `${stats.fecha_minima} - ${stats.fecha_maxima}`;
                }
                
                if (stats.conceptos_unicos !== undefined) {
                    document.getElementById('conceptos-unicos-original').textContent = stats.conceptos_unicos;
                }
                
                if (stats.estados_unicos !== undefined) {
                    document.getElementById('total-estados-original').textContent = stats.estados_unicos;
                } else {
                    document.getElementById('total-estados-original').textContent = '32';
                }
                
                console.log('‚úÖ Base original actualizada');
                
            } catch (error) {
                console.error('‚ùå Error cargando estad√≠sticas originales:', error);
                document.getElementById('total-registros-original').textContent = 'Error';
                document.getElementById('periodo-original').textContent = 'Error';
                document.getElementById('conceptos-unicos-original').textContent = 'Error';
                document.getElementById('total-estados-original').textContent = 'Error';
            }
        }
        
        // Funci√≥n para cargar estad√≠sticas de la base PROCESADA
        async function loadProcessedStats() {
            try {
                console.log('üîÑ Cargando estad√≠sticas de base procesada...');
                const response = await fetch('data/stats_processed.json');
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const stats = await response.json();
                console.log('‚úÖ Estad√≠sticas procesadas cargadas:', stats);
                
                // Actualizar elementos de la base PROCESADA
                if (stats.total_registros_procesados !== undefined) {
                    document.getElementById('total-registros-procesados').textContent = stats.total_registros_procesados.toLocaleString();
                }
                
                if (stats.fecha_minima_procesada && stats.fecha_maxima_procesada) {
                    document.getElementById('periodo-procesado').textContent = `${stats.fecha_minima_procesada} - ${stats.fecha_maxima_procesada}`;
                }
                
                if (stats.conceptos_unicos_procesados !== undefined) {
                    document.getElementById('conceptos-unicos-procesados').textContent = stats.conceptos_unicos_procesados;
                }
                
                if (stats.estados_unicos_procesados !== undefined) {
                    document.getElementById('total-estados-procesados').textContent = stats.estados_unicos_procesados;
                }
                
                console.log('‚úÖ Base procesada actualizada');
                
            } catch (error) {
                console.error('‚ùå Error cargando estad√≠sticas procesadas:', error);
                document.getElementById('total-registros-procesados').textContent = 'Error';
                document.getElementById('periodo-procesado').textContent = 'Error';
                document.getElementById('conceptos-unicos-procesados').textContent = 'Error';
                document.getElementById('total-estados-procesados').textContent = 'Error';
            }
        }
        
        // Funci√≥n para cargar preview de la base PROCESADA (solo esta)
        async function loadProcessedPreview() {
            try {
                console.log('üîÑ Cargando preview de base procesada...');
                const response = await fetch('data/preview_processed.json');
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const previewData = await response.json();
                updatePreviewTable('preview-table-procesados', previewData);
                console.log('‚úÖ Preview procesado actualizado');
                
            } catch (error) {
                console.error('‚ùå Error cargando preview procesado:', error);
                document.getElementById('preview-table-procesados').innerHTML = '<tbody><tr><td>Error cargando preview</td></tr></tbody>';
            }
        }
        
        // Funci√≥n auxiliar para actualizar tabla de preview
        function updatePreviewTable(tableId, previewData) {
            if (previewData.length > 0) {
                const columns = Object.keys(previewData[0]);
                
                let tableHTML = '<thead><tr>';
                columns.forEach(col => {
                    tableHTML += `<th>${col}</th>`;
                });
                tableHTML += '</tr></thead><tbody>';
                
                previewData.forEach(row => {
                    tableHTML += '<tr>';
                    columns.forEach(col => {
                        const value = row[col] || '';
                        tableHTML += `<td>${value}</td>`;
                    });
                    tableHTML += '</tr>';
                });
                
                tableHTML += '</tbody>';
                document.getElementById(tableId).innerHTML = tableHTML;
            }
        }

        // Funci√≥n para crear el stacked chart nacional
        function createNationalStackedChart() {
            // Obtener el canvas
            const ctx = document.getElementById('nationalChart').getContext('2d');
            
            // Datos del CSV (esto se cargar√° din√°micamente)
            const chartData = {
                labels: ['2019', '2020', '2021', '2022', '2023', '2024', '2025'],
                datasets: []
            };
            
            // Colores consistentes para cada concepto
            const conceptColors = {
                'OTRAS LEYES Y CODIGOS': '#FF6384',
                'OTROS DELITOS': '#36A2EB', 
                'CONTRA LA SALUD': '#FFCE56',
                'LEY GENERAL DE SALUD (L.G.S.)': '#4BC0C0',
                'LEY FEDERAL CONTRA LA DELINCUENCIA ORGANIZADA (L.F.C.D.O.)': '#FF9F40'
            };
            
            // Colores de respaldo
            const colors = [
                '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF',
                '#FF9F40', '#FF6384', '#C9CBCF', '#4BC0C0', '#FF6384'
            ];
            
            // Cargar datos del CSV
            fetch('data/national_concept_analysis.csv')
                .then(response => response.text())
                .then(csvText => {
                    const lines = csvText.split('\n');
                    const headers = lines[0].split(',');
                    const years = headers.slice(1); // A√±os (2019, 2020, etc.)
                    
                    // Procesar cada l√≠nea (concepto)
                    for (let i = 1; i < lines.length; i++) {
                        if (lines[i].trim()) {
                            const values = lines[i].split(',');
                            const concepto = values[0];
                            const data = values.slice(1).map(val => parseInt(val) || 0);
                            
                            // Crear dataset para este concepto
                            chartData.datasets.push({
                                label: concepto,
                                data: data,
                                backgroundColor: conceptColors[concepto] || colors[i % colors.length],
                                borderColor: conceptColors[concepto] || colors[i % colors.length],
                                borderWidth: 1,
                            });
                        }
                    }
                    
                    // Crear el chart
                    new Chart(ctx, {
                        type: 'bar',
                        data: chartData,
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: {
                                    position: 'bottom',
                                    labels: {
                                        usePointStyle: true,
                                        padding: 20
                                    }
                                },
                                tooltip: {
                                    mode: 'index',
                                    intersect: false,
                                    callbacks: {
                                        label: function(context) {
                                            return context.dataset.label + ': ' + context.parsed.y.toLocaleString() + ' casos';
                                        }
                                    }
                                }
                            },
                            scales: {
                                x: {
                                    title: {
                                        display: true,
                                        text: 'A√±o (enero-julio)'
                                    }
                                },
                                y: {
                                    title: {
                                        display: true,
                                        text: 'N√∫mero de carpetas de investigaci√≥n'
                                    },
                                    ticks: {
                                        callback: function(value) {
                                            return value.toLocaleString();
                                        }
                                    }
                                }
                            },
                            interaction: {
                                mode: 'nearest',
                                axis: 'x',
                                intersect: false
                            }
                        }
                    });
                })
                .catch(error => {
                    console.error('Error cargando datos:', error);
                });
        }


                // Funci√≥n para cargar la tabla de datos nacionales
        async function loadNationalTable() {
            try {
                console.log('üîÑ Cargando tabla de datos nacionales...');
                const response = await fetch('data/national_concept_analysis.csv');
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const csvText = await response.text();
                const rows = csvText.split('\n');
                const headers = rows[0].split(',');
                
                // Crear tabla HTML
                let tableHTML = '<thead><tr>';
                headers.forEach(header => {
                    tableHTML += `<th>${header}</th>`;
                });
                tableHTML += '<th>Total</th></tr></thead><tbody>';
                
                // Procesar filas de datos (saltar la primera que son headers)
                for (let i = 1; i < rows.length; i++) {
                    if (rows[i].trim() === '') continue; // Saltar filas vac√≠as
                    
                    const values = rows[i].split(',');
                    if (values.length < headers.length) continue; // Saltar filas incompletas
                    
                    tableHTML += '<tr>';
                    
                    // Primera columna (Concepto)
                    tableHTML += `<td>${values[0]}</td>`;
                    
                    // Columnas de a√±os (convertir a n√∫meros y formatear)
                    let total = 0;
                    for (let j = 1; j < values.length; j++) {
                        const value = parseInt(values[j]) || 0;
                        total += value;
                        tableHTML += `<td class="text-right">${value.toLocaleString()}</td>`;
                    }
                    
                    // Columna de total
                    tableHTML += `<td class="text-right total-cell"><strong>${total.toLocaleString()}</strong></td>`;
                    
                    tableHTML += '</tr>';
                }
                
                tableHTML += '</tbody>';
                
                // Actualizar la tabla
                document.getElementById('national-concept-table').innerHTML = tableHTML;
                console.log('‚úÖ Tabla nacional actualizada');
                
            } catch (error) {
                console.error('‚ùå Error cargando tabla nacional:', error);
                document.getElementById('national-concept-table').innerHTML = 
                    '<tbody><tr><td colspan="8">Error cargando datos</td></tr></tbody>';
            }
        }

        // ===== FUNCI√ìN PARA CARGAR TABLA DE CAMBIOS PORCENTUALES =====
        
        async function loadPercentageChangesTable() {
            try {
                console.log('üîÑ Cargando tabla de cambios porcentuales...');
                const response = await fetch('data/national_percentage_analysis.csv');
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const csvText = await response.text();
                const rows = csvText.split('\n');
                const headers = rows[0].split(',');
                
                // Crear tabla HTML
                let tableHTML = '<thead><tr>';
                headers.forEach(header => {
                    tableHTML += `<th>${header}</th>`;
                });
                tableHTML += '</tr></thead><tbody>';
                
                // Procesar filas de datos (saltar la primera que son headers)
                for (let i = 1; i < rows.length; i++) {
                    if (rows[i].trim() === '') continue; // Saltar filas vac√≠as
                    
                    const values = rows[i].split(',');
                    if (values.length < headers.length) continue; // Saltar filas incompletas
                    
                    tableHTML += '<tr>';
                    
                    // Primera columna (Concepto)
                    tableHTML += `<td>${values[0]}</td>`;
                    
                    // Columnas de a√±os (cambios porcentuales)
                    for (let j = 1; j < values.length; j++) {
                        const value = parseFloat(values[j]) || 0;
                        
                        // Formatear cambios porcentuales con colores
                        let cellClass = 'text-right';
                        let displayValue = value;
                        
                        if (value > 0) {
                            cellClass += ' positive-change';
                            displayValue = `+${value.toFixed(1)}%`;
                        } else if (value < 0) {
                            cellClass += ' negative-change';
                            displayValue = `${value.toFixed(1)}%`;
                        } else {
                            displayValue = '0.0%';
                        }
                        
                        tableHTML += `<td class="${cellClass}">${displayValue}</td>`;
                    }
                    
                    tableHTML += '</tr>';
                }
                
                tableHTML += '</tbody>';
                
                // Actualizar la tabla
                document.getElementById('percentage-changes-table').innerHTML = tableHTML;
                console.log('‚úÖ Tabla de cambios porcentuales actualizada');
                
            } catch (error) {
                console.error('‚ùå Error cargando tabla de cambios porcentuales:', error);
                document.getElementById('percentage-changes-table').innerHTML = 
                    '<tbody><tr><td colspan="7">Error cargando datos</td></tr></tbody>';
            }
        }
        // Funci√≥n para crear 7 pie charts nacionales (uno por a√±o)
        function createNationalPieCharts() {
            // Colores consistentes para cada concepto (mismos que en la gr√°fica 1)
            const conceptColors = {
                'OTRAS LEYES Y CODIGOS': '#FF6384',
                'OTROS DELITOS': '#36A2EB', 
                'CONTRA LA SALUD': '#FFCE56',
                'LEY GENERAL DE SALUD (L.G.S.)': '#4BC0C0',
                'LEY FEDERAL CONTRA LA DELINCUENCIA ORGANIZADA (L.F.C.D.O.)': '#FF9F40'
            };
            
            // Colores de respaldo
            const colors = [
                '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF',
                '#FF9F40', '#FF6384', '#C9CBCF', '#4BC0C0', '#FF6384'
            ];
            
            // A√±os disponibles
            const years = ['2019', '2020', '2021', '2022', '2023', '2024', '2025'];
            
            // Cargar datos del CSV
            fetch('data/national_concept_analysis.csv')
                .then(response => response.text())
                .then(csvText => {
                    const lines = csvText.split('\n');
                    const headers = lines[0].split(',');
                    
                    // Procesar cada l√≠nea (concepto)
                    const conceptData = [];
                    for (let i = 1; i < lines.length; i++) {
                        if (lines[i].trim()) {
                            const values = lines[i].split(',');
                            const concepto = values[0];
                            const data = values.slice(1).map(val => parseInt(val) || 0);
                            
                            conceptData.push({
                                concepto: concepto,
                                data: data
                            });
                        }
                    }
                    
                    // Crear un pie chart para cada a√±o
                    years.forEach((year, yearIndex) => {
                        const canvasId = `pieChart${year}`;
                        const canvas = document.getElementById(canvasId);
                        
                        if (canvas) {
                            const ctx = canvas.getContext('2d');
                            
                            // Preparar datos para este a√±o espec√≠fico
                            const chartData = {
                                labels: conceptData.map(item => item.concepto),
                                datasets: [{
                                    data: conceptData.map(item => item.data[yearIndex]),
                                    backgroundColor: conceptData.map(item => conceptColors[item.concepto] || colors[conceptData.indexOf(item) % colors.length]),
                                    borderColor: conceptData.map(item => conceptColors[item.concepto] || colors[conceptData.indexOf(item) % colors.length]),
                                    borderWidth: 2,
                                    hoverOffset: 4
                                }]
                            };
                            
                            // Crear el donut chart para este a√±o
                            new Chart(ctx, {
                                type: 'doughnut',
                                data: chartData,
                                options: {
                                    responsive: true,
                                    maintainAspectRatio: false,
                                    cutout: '40%',  // Tama√±o del agujero central
                                    plugins: {
                                        title: {
                                            display: true,
                                            text: `A√±o ${year}`,
                                            font: {
                                                size: 16
                                            }
                                        },
                                        legend: {
                                            display: false
                                        },
                                        tooltip: {
                                            callbacks: {
                                                label: function(context) {
                                                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                                    const percentage = ((context.parsed / total) * 100).toFixed(1);
                                                    const shortLabel = context.label.length > 30 ? 
                                                        context.label.substring(0, 15) + '...' : 
                                                        context.label;
                                                    return shortLabel + ': ' + context.parsed.toLocaleString() + ' casos (' + percentage + '%)';
                                                }
                                            }
                                        }
                                    }
                                }
                            });
                        }
                    });
                })
                .catch(error => {
                    console.error('Error cargando datos:', error);
                });
        }

        // ===== GR√ÅFICA 3: DISTRIBUCI√ìN DE TIPOS POR CONCEPTO =====

        // Variables globales para la gr√°fica 3
        let typeChartData = null;
        let currentConcept = '';

        // Funci√≥n para cargar los conceptos disponibles
        async function loadAvailableConcepts() {
            try {
                const response = await fetch('data/type_distribution_analysis.csv');
                const csvText = await response.text();
                
                const lines = csvText.split('\n');
                const headers = lines[0].split(',');
                
                // Obtener conceptos √∫nicos
                const concepts = new Set();
                for (let i = 1; i < lines.length; i++) {
                    if (lines[i].trim()) {
                        const values = lines[i].split(',');
                        if (values.length > 1) {
                            concepts.add(values[0]); // Primera columna es CONCEPTO
                        }
                    }
                }
                
                // Llenar el selector
                const select = document.getElementById('concept-select');
                select.innerHTML = '<option value="">Selecciona un concepto...</option>';
                
                Array.from(concepts).sort().forEach(concept => {
                    const option = document.createElement('option');
                    option.value = concept;
                    option.textContent = concept;
                    select.appendChild(option);
                });
                
                // Cargar datos completos
                typeChartData = parseCSVToData(csvText);
                
                        // Event listener para cambios en el selector
        select.addEventListener('change', function() {
            currentConcept = this.value;
            if (currentConcept) {
                createTypePieCharts(currentConcept);
                document.getElementById('type-charts-container').style.display = 'block';
            } else {
                document.getElementById('type-charts-container').style.display = 'none';
            }
        });
                
            } catch (error) {
                console.error('‚ùå Error cargando conceptos:', error);
            }
        }

        // Funci√≥n para parsear CSV a datos estructurados CORREGIDA
function parseCSVToData(csvText) {
    const lines = csvText.split('\n');
    const headers = [];
    
    // Parsear headers manualmente para manejar comillas correctamente
    const firstLine = lines[0];
    let currentHeader = '';
    let inQuotes = false;
    
    for (let i = 0; i < firstLine.length; i++) {
        const char = firstLine[i];
        
        if (char === '"') {
            inQuotes = !inQuotes;
        } else if (char === ',' && !inQuotes) {
            headers.push(currentHeader.trim());
            currentHeader = '';
        } else {
            currentHeader += char;
        }
    }
    headers.push(currentHeader.trim()); // √öltimo header
    
    const data = {};
    
    for (let i = 1; i < lines.length; i++) {
        if (lines[i].trim()) {
            // Parsear valores de la misma manera para manejar comillas
            const values = [];
            let currentValue = '';
            let inQuotes = false;
            
            for (let j = 0; j < lines[i].length; j++) {
                const char = lines[i][j];
                
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    values.push(currentValue.trim());
                    currentValue = '';
                } else {
                    currentValue += char;
                }
            }
            values.push(currentValue.trim()); // √öltimo valor
            
            const concepto = values[0];
            const a√±o = values[1];
            
            if (!data[concepto]) {
                data[concepto] = {};
            }
            
            data[concepto][a√±o] = {};
            
            // Agregar datos de tipos (columnas 2 en adelante)
            // El CSV tiene columnas fijas para todos los conceptos
            for (let j = 2; j < headers.length; j++) {
                const tipo = headers[j];
                // Solo procesar si es un tipo v√°lido (no CONCEPTO ni A√ëO)
                if (tipo !== 'CONCEPTO' && tipo !== 'A√ëO') {
                    // Manejar valores vac√≠os correctamente
                    let valor = 0;
                    if (values[j] && values[j].trim() !== '') {
                        valor = parseInt(values[j]) || 0;
                    }
                    data[concepto][a√±o][tipo] = valor;
                }
            }
        }
    }
    
    return data;
}

        // Funci√≥n para generar colores flexibles √∫nicos basados en los tipos disponibles
        function generateFlexibleColors(tipos) {
            // Paleta de colores √∫nicos y visualmente distintos
            const uniqueColors = [
                '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF',
                '#FF9F40', '#8AC249', '#FF6B6B', '#4ECDC4', '#45B7D1',
                '#96CEB4', '#FFEAA7', '#DDA0DD', '#98D8C8', '#F7DC6F',
                '#BB8FCE', '#85C1E9', '#F8C471', '#82E0AA', '#F1948A',
                '#D7BDE2', '#A9CCE3', '#F5B7B1', '#D2B4DE', '#AED6F1'
            ];
            
            // Crear mapeo de colores √∫nicos para cada tipo
            const colorMap = {};
            
            tipos.forEach((tipo, index) => {
                // Asignar color √∫nico directamente por √≠ndice
                colorMap[tipo] = uniqueColors[index];
            });
            
                    return colorMap;
    }

    // Funci√≥n para crear la tabla de datos de la Gr√°fica 3
    function createTypeDistributionTable(concepto) {
        if (!typeChartData || !typeChartData[concepto]) {
            console.error('No hay datos para el concepto:', concepto);
            return;
        }
        
        const years = ['2019', '2020', '2021', '2022', '2023', '2024', '2025'];
        const conceptData = typeChartData[concepto];
        
        // Obtener todos los tipos √∫nicos para este concepto
        // El CSV tiene columnas fijas, pero solo mostramos las que tienen datos reales para este concepto
        const allTipos = new Set();
        years.forEach(year => {
            if (conceptData[year]) {
                Object.keys(conceptData[year]).forEach(tipo => {
                    const valor = conceptData[year][tipo];
                    // Solo incluir tipos que realmente tienen valores > 0 para este concepto espec√≠fico
                    if (valor > 0 && 
                        tipo !== 'CONCEPTO' && 
                        tipo !== 'A√ëO' &&
                        typeof valor === 'number' &&
                        !isNaN(valor)) {
                        allTipos.add(tipo);
                    }
                });
            }
        });
        
        const tipos = Array.from(allTipos).sort();
                
                // Crear tabla HTML
        let tableHTML = '<thead><tr><th>Tipo</th>';
        years.forEach(year => {
            tableHTML += `<th>${year}</th>`;
                });
                tableHTML += '</tr></thead><tbody>';
                
        // Procesar cada tipo
        tipos.forEach(tipo => {
            tableHTML += '<tr>';
            tableHTML += `<td>${tipo}</td>`;
            
            // Agregar valores para cada a√±o
            years.forEach(year => {
                const value = conceptData[year] && conceptData[year][tipo] ? conceptData[year][tipo] : 0;
                tableHTML += `<td class="text-right">${value.toLocaleString()}</td>`;
            });
            
            tableHTML += '</tr>';
        });
        
        tableHTML += '</tbody>';
        
        // Buscar la tabla de la Gr√°fica 3 por el t√≠tulo
        const tableContainers = document.querySelectorAll('.table-container');
        let targetTable = null;
        
        for (let container of tableContainers) {
            const h3 = container.querySelector('h3');
            if (h3 && h3.textContent.includes('Tabla 2')) {
                targetTable = container;
                break;
            }
        }
        
        if (targetTable) {
            let table = targetTable.querySelector('table');
            if (!table) {
                // Crear tabla si no existe
                table = document.createElement('table');
                table.className = 'data-table';
                targetTable.appendChild(table);
            }
            table.innerHTML = tableHTML;
        }
        
        console.log('‚úÖ Tabla de distribuci√≥n de tipos creada para:', concepto);
    }

    // Funci√≥n para crear la tabla de cambios porcentuales de la Gr√°fica 3
    function createTypePercentageTable(concepto) {
        if (!typeChartData || !typeChartData[concepto]) {
            console.error('No hay datos para el concepto:', concepto);
            return;
        }
        
        const years = ['2019', '2020', '2021', '2022', '2023', '2024', '2025'];
        const conceptData = typeChartData[concepto];
        
        // Obtener todos los tipos √∫nicos para este concepto
        const allTipos = new Set();
        years.forEach(year => {
            if (conceptData[year]) {
                Object.keys(conceptData[year]).forEach(tipo => {
                    const valor = conceptData[year][tipo];
                    if (valor > 0 && 
                        tipo !== 'CONCEPTO' && 
                        tipo !== 'A√ëO' &&
                        typeof valor === 'number' &&
                        !isNaN(valor)) {
                        allTipos.add(tipo);
                    }
                });
            }
        });
        
        const tipos = Array.from(allTipos).sort();
        
        // Crear tabla HTML
        let tableHTML = '<thead><tr><th>Tipo</th>';
        years.forEach(year => {
            tableHTML += `<th>${year}</th>`;
        });
        tableHTML += '</tr></thead><tbody>';
        
        // Procesar cada tipo
        tipos.forEach(tipo => {
                    tableHTML += '<tr>';
            tableHTML += `<td>${tipo}</td>`;
            
            // Agregar cambios porcentuales para cada a√±o
            years.forEach((year, yearIndex) => {
                if (yearIndex === 0) {
                    // Para 2019, usar 2018 como a√±o base si est√° disponible
                    const year2018 = conceptData['2018'];
                    const year2019 = conceptData[year];
                    
                    if (year2018 && year2018[tipo] && year2018[tipo] > 0 && 
                        year2019 && year2019[tipo] && year2019[tipo] > 0) {
                        
                        const percentageChange = ((year2019[tipo] - year2018[tipo]) / year2018[tipo]) * 100;
                        
                        // Formatear cambios porcentuales con colores
                        let cellClass = 'text-right';
                        let displayValue = '-';
                        
                        if (percentageChange > 0) {
                            cellClass += ' positive-change';
                            displayValue = `+${percentageChange.toFixed(1)}%`;
                        } else if (percentageChange < 0) {
                            cellClass += ' negative-change';
                            displayValue = `${percentageChange.toFixed(1)}%`;
                        } else {
                            displayValue = '0.0%';
                        }
                        
                        tableHTML += `<td class="${cellClass}">${displayValue}</td>`;
                    } else {
                        // Si no hay datos de 2018 o 2019, mostrar gui√≥n
                        tableHTML += '<td class="text-right">-</td>';
                    }
                } else {
                    const currentYear = parseInt(year);
                    const previousYear = currentYear - 1;
                    const currentValue = conceptData[year] && conceptData[year][tipo] ? conceptData[year][tipo] : 0;
                    const previousValue = conceptData[previousYear] && conceptData[previousYear][tipo] ? conceptData[previousYear][tipo] : 0;
                    
                    let percentageChange = 0;
                    if (previousValue > 0) {
                        percentageChange = ((currentValue - previousValue) / previousValue) * 100;
                    }
                    
                    // Formatear cambios porcentuales con colores
                    let cellClass = 'text-right';
                    let displayValue = '-';
                    
                    if (previousValue > 0) {
                        if (percentageChange > 0) {
                            cellClass += ' positive-change';
                            displayValue = `+${percentageChange.toFixed(1)}%`;
                        } else if (percentageChange < 0) {
                            cellClass += ' negative-change';
                            displayValue = `${percentageChange.toFixed(1)}%`;
                        } else {
                            displayValue = '0.0%';
                        }
                    }
                    
                    tableHTML += `<td class="${cellClass}">${displayValue}</td>`;
                }
            });
            
            tableHTML += '</tr>';
        });
                
                tableHTML += '</tbody>';
                
        // Buscar la tabla de la Gr√°fica 3 por el t√≠tulo
        const tableContainers = document.querySelectorAll('.table-container');
        let targetTable = null;
        
        for (let container of tableContainers) {
            const h3 = container.querySelector('h3');
            if (h3 && h3.textContent.includes('Tabla 2.1')) {
                targetTable = container;
                break;
            }
        }
        
        if (targetTable) {
            let table = targetTable.querySelector('table');
            if (!table) {
                // Crear tabla si no existe
                table = document.createElement('table');
                table.className = 'data-table';
                targetTable.appendChild(table);
            }
            table.innerHTML = tableHTML;
        }
        
        console.log('‚úÖ Tabla de cambios porcentuales creada para:', concepto);
    }

    // Funci√≥n para crear los pie charts de tipos
        function createTypePieCharts(concepto) {
            if (!typeChartData || !typeChartData[concepto]) {
                console.error('No hay datos para el concepto:', concepto);
                return;
            }
            
            const years = ['2019', '2020', '2021', '2022', '2023', '2024', '2025'];
            const conceptData = typeChartData[concepto];
            
            // Obtener todos los tipos √∫nicos para este concepto
            const allTipos = new Set();
            years.forEach(year => {
                if (conceptData[year]) {
                    Object.keys(conceptData[year]).forEach(tipo => {
                        if (conceptData[year][tipo] > 0) {
                            allTipos.add(tipo);
                        }
                    });
                }
            });
            
            // Generar colores flexibles para todos los tipos
            const typeColors = generateFlexibleColors(Array.from(allTipos));
            
            // Crear un pie chart para cada a√±o
            years.forEach(year => {
                const canvasId = `typePieChart${year}`;
                const canvas = document.getElementById(canvasId);
                
                if (canvas && conceptData[year]) {
                    const ctx = canvas.getContext('2d');
                    
                    // Destruir chart anterior si existe
                    if (window[`typeChart${year}`]) {
                        window[`typeChart${year}`].destroy();
                    }
                    
                                // Preparar datos para este a√±o
            const yearData = conceptData[year];
            // Filtrar solo tipos con valores > 0 para este concepto espec√≠fico
            // El CSV tiene columnas fijas, pero solo mostramos las que tienen datos reales
            const tipos = Object.keys(yearData).filter(tipo => {
                const valor = yearData[tipo];
                // Solo incluir tipos que realmente tienen valores > 0 para este concepto
                return valor > 0 && 
                       tipo !== 'CONCEPTO' && 
                       tipo !== 'A√ëO' &&
                       typeof valor === 'number' &&
                       !isNaN(valor);
            });
            const valores = tipos.map(tipo => yearData[tipo]);
                    
                    // Preparar colores usando el mapeo flexible
                    const backgroundColor = tipos.map(tipo => typeColors[tipo]);
                    const borderColor = backgroundColor;
                    
                    const chartData = {
                        labels: tipos,
                        datasets: [{
                            data: valores,
                            backgroundColor: backgroundColor,
                            borderColor: borderColor,
                            borderWidth: 2,
                            hoverOffset: 4
                        }]
                    };
                    
                                // Crear el donut chart
            window[`typeChart${year}`] = new Chart(ctx, {
                type: 'doughnut',
                data: chartData,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    cutout: '40%',  // Tama√±o del agujero central
                    plugins: {
                        title: {
                            display: true,
                            text: `A√±o ${year}`,
                            font: { size: 16 }
                        },
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                    const percentage = ((context.parsed / total) * 100).toFixed(1);
                                    
                                    // Acortar nombres largos inteligentemente
                                    let shortLabel = context.label;
                                    if (context.label.length > 30) {
                                        // Buscar el √∫ltimo espacio antes del l√≠mite
                                        const lastSpace = context.label.lastIndexOf(' ', 30);
                                        if (lastSpace > 20) {
                                            shortLabel = context.label.substring(0, lastSpace) + '...';
                                        } else {
                                            shortLabel = context.label.substring(0, 30) + '...';
                                        }
                                    }
                                    
                                    return shortLabel + ': ' + context.parsed.toLocaleString() + ' casos (' + percentage + '%)';
                                }
                            }
                        }
                    }
                }
            });
                }
            });
            
                console.log('‚úÖ Pie charts de tipos creados para:', concepto);
    console.log('üé® Tipos encontrados:', Array.from(allTipos));
    console.log('üé® Colores asignados:', typeColors);
    
    // Crear tambi√©n la tabla de datos
    createTypeDistributionTable(concepto);
    
    // Crear tambi√©n la tabla de cambios porcentuales
    createTypePercentageTable(concepto);
}
        // ===== EVENT LISTENERS Y INICIALIZACI√ìN =====
        
        // Cargar todos los datos cuando la p√°gina se cargue
        document.addEventListener('DOMContentLoaded', function() {
            console.log('üöÄ P√°gina cargada, iniciando carga de datos...');
            
            // Cargar estad√≠sticas
            loadOriginalStats();
            loadProcessedStats();
            loadProcessedPreview();
            loadNationalTable();
            loadPercentageChangesTable();
            loadAvailableConcepts();
            
            // Crear gr√°fica nacional
            createNationalStackedChart();
            createNationalPieCharts();
            
            // Crear mapa de estados
            createEstadosMap();
            
            // Cargar conceptos para el mapa
            loadAvailableConceptsForMap();
        });
        
        // Event listeners adicionales para debugging
        document.querySelectorAll('.content-section').forEach(section => {
            section.addEventListener('click', function() {
                console.log('Section clicked:', this.querySelector('h2').textContent);
            });
        });

        // ===== FUNCIONES PARA MAPAS =====
        
        // Variables globales para el mapa
        let map = null;
        let entidadConceptoData = null;
        let currentConcepto = null;
        let currentYear = 2019;
        
        // Funci√≥n para cargar los conceptos disponibles
        async function loadAvailableConceptsForMap() {
            try {
                console.log('üîÑ Cargando conceptos para el mapa...');
                
                const response = await fetch('data/entidad_concepto_analysis.csv');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const csvText = await response.text();
                console.log('‚úÖ CSV cargado, longitud:', csvText.length);
                
                // Parsear CSV
                const lines = csvText.split('\n');
                console.log('üìä L√≠neas en CSV:', lines.length);
                console.log('üìã Headers:', lines[0]);
                
                const headers = lines[0].split(',');
                const conceptos = [...new Set(lines.slice(1).map(line => {
                    const values = line.split(',');
                    return values[1]; // CONCEPTO est√° en la columna 1
                }).filter(Boolean))];
                
                console.log('üéØ Conceptos encontrados:', conceptos);
                
                // Cargar datos completos
                entidadConceptoData = parseCSVToEntidadConceptoData(csvText);
                console.log('üìä Datos parseados:', entidadConceptoData);
                
                // Poblar selector
                const selector = document.getElementById('map-concept-selector');
                if (!selector) {
                    console.error('‚ùå Selector no encontrado');
                    return;
                }
                
                selector.innerHTML = '<option value="">Selecciona un concepto</option>';
                conceptos.forEach(concepto => {
                    const option = document.createElement('option');
                    option.value = concepto;
                    option.textContent = concepto;
                    selector.appendChild(option);
                });
                
                console.log('‚úÖ Selector poblado con', conceptos.length, 'conceptos');
                
                // Event listener para cambios de concepto
                selector.addEventListener('change', function() {
                    currentConcepto = this.value;
                    console.log('üéØ Concepto seleccionado:', currentConcepto);
                    if (currentConcepto) {
                        updateMapColors(currentConcepto, currentYear);
                    }
                });
                
                // Configurar slider de a√±o
                const yearSlider = document.getElementById('map-year-slider');
                const yearDisplay = document.getElementById('year-display');
                
                if (yearSlider && yearDisplay) {
                    // Event listener para cambios del slider
                    yearSlider.addEventListener('input', function() {
                        currentYear = parseInt(this.value);
                        yearDisplay.textContent = currentYear;
                        
                        if (currentConcepto) {
                            updateMapColors(currentConcepto, currentYear);
                        }
                    });
                    
                    console.log('‚úÖ Slider de a√±o configurado');
                }
                
            } catch (error) {
                console.error('‚ùå Error cargando conceptos para mapa:', error);
            }
        }
        
        // Funci√≥n para mapear nombres de entidades del CSV a los del GeoJSON
        function mapEntidadName(csvName) {
            const mapping = {
                'AGUASCALIENTES': 'Aguascalientes',
                'BAJA CALIFORNIA': 'Baja California',
                'BAJA CALIFORNIA SUR': 'Baja California Sur',
                'CAMPECHE': 'Campeche',
                'COAHUILA': 'Coahuila de Zaragoza',
                'COLIMA': 'Colima',
                'CHIAPAS': 'Chiapas',
                'CHIHUAHUA': 'Chihuahua',
                'CIUDAD DE MEXICO': 'Ciudad de M√©xico',
                'DURANGO': 'Durango',
                'GUANAJUATO': 'Guanajuato',
                'GUERRERO': 'Guerrero',
                'HIDALGO': 'Hidalgo',
                'JALISCO': 'Jalisco',
                'MEXICO': 'M√©xico',
                'MICHOACAN': 'Michoac√°n de Ocampo',
                'MORELOS': 'Morelos',
                'NAYARIT': 'Nayarit',
                'NUEVO LEON': 'Nuevo Le√≥n',
                'OAXACA': 'Oaxaca',
                'PUEBLA': 'Puebla',
                'QUERETARO': 'Quer√©taro',
                'QUINTANA ROO': 'Quintana Roo',
                'SAN LUIS POTOSI': 'San Luis Potos√≠',
                'SINALOA': 'Sinaloa',
                'SONORA': 'Sonora',
                'TABASCO': 'Tabasco',
                'TAMAULIPAS': 'Tamaulipas',
                'TLAXCALA': 'Tlaxcala',
                'VERACRUZ': 'Veracruz de Ignacio de la Llave',
                'YUCATAN': 'Yucat√°n',
                'ZACATECAS': 'Zacatecas'
            };
            
            return mapping[csvName] || csvName;
        }
        
        // Funci√≥n para parsear CSV de entidad-concepto
        function parseCSVToEntidadConceptoData(csvText) {
            const lines = csvText.split('\n');
            const headers = lines[0].split(',');
            const data = {};
            
            lines.slice(1).forEach(line => {
                if (line.trim()) {
                    const values = line.split(',');
                    const entidad = values[0];
                    const concepto = values[1];
                    
                    // Mapear nombre de entidad del CSV al del GeoJSON
                    const entidadMapeada = mapEntidadName(entidad);
                    
                    if (!data[entidadMapeada]) data[entidadMapeada] = {};
                    if (!data[entidadMapeada][concepto]) data[entidadMapeada][concepto] = {};
                    
                    // Agregar a√±os
                    for (let i = 2; i < headers.length; i++) {
                        const year = headers[i];
                        const value = parseInt(values[i]) || 0;
                        data[entidadMapeada][concepto][year] = value;
                    }
                }
            });
            
            return data;
        }
        
        // Funci√≥n para actualizar colores del mapa seg√∫n el concepto y a√±o
        function updateMapColors(concepto, year) {
            console.log('üîÑ Actualizando colores del mapa para concepto:', concepto, 'a√±o:', year);
            console.log('üìä Datos disponibles:', entidadConceptoData);
            
            if (!map || !entidadConceptoData) {
                console.error('‚ùå Mapa o datos no disponibles');
                return;
            }
            
            // Obtener todos los valores para este concepto y a√±o espec√≠fico
            const allValues = [];
            Object.values(entidadConceptoData).forEach(entidadData => {
                if (entidadData[concepto] && entidadData[concepto][year]) {
                    const value = entidadData[concepto][year];
                    if (value > 0) allValues.push(value);
                }
            });
            
            console.log('üìà Valores encontrados para', concepto, 'en', year, ':', allValues);
            
            if (allValues.length === 0) {
                console.error('‚ùå No hay valores para el concepto:', concepto, 'en a√±o:', year);
                return;
            }
            
            // Calcular percentiles para la escala de colores (5 niveles)
            allValues.sort((a, b) => a - b);
            const q20 = allValues[Math.floor(allValues.length * 0.20)];
            const q40 = allValues[Math.floor(allValues.length * 0.40)];
            const q60 = allValues[Math.floor(allValues.length * 0.60)];
            const q80 = allValues[Math.floor(allValues.length * 0.80)];
            
            console.log('üìä Percentiles - Q20:', q20, 'Q40:', q40, 'Q60:', q60, 'Q80:', q80);
            
            // Actualizar colores de los estados
            let estadosActualizados = 0;
            map.eachLayer(layer => {
                if (layer.feature && layer.feature.properties) {
                    const entidad = layer.feature.properties.NOMGEO;
                    console.log('üó∫Ô∏è Procesando entidad:', entidad);
                    
                    const entidadData = entidadConceptoData[entidad];
                    
                    if (entidadData && entidadData[concepto] && entidadData[concepto][year]) {
                        // Usar el valor del a√±o espec√≠fico
                        const value = entidadData[concepto][year];
                        
                        console.log(`   üìä ${entidad}: A√±o ${year} = ${value}`);
                        
                        // Asignar color seg√∫n el valor (escala blanco a rojo con 5 niveles)
                        let color;
                        if (value <= q20) {
                            color = '#ffffff'; // Blanco (muy baja incidencia)
                        } else if (value <= q40) {
                            color = '#ffe6e6'; // Rosa muy claro (baja incidencia)
                        } else if (value <= q60) {
                            color = '#ffcccc'; // Rosa claro (media-baja incidencia)
                        } else if (value <= q80) {
                            color = '#ff9999'; // Rosa medio (media-alta incidencia)
                        } else {
                            color = '#ff0000'; // Rojo (alta incidencia)
                        }
                        
                        layer.setStyle({
                            fillColor: color,
                            fillOpacity: 0.8
                        });
                        
                        // Actualizar el popup con los nuevos datos
                        const nombre = layer.feature.properties.NOMGEO;
                        let popupContent = `<b>${nombre}</b>`;
                        
                        if (entidadConceptoData && currentConcepto && currentYear) {
                            const entidadData = entidadConceptoData[nombre];
                            if (entidadData && entidadData[currentConcepto] && entidadData[currentConcepto][currentYear]) {
                                const value = entidadData[currentConcepto][currentYear];
                                popupContent += `<br><br><b>Concepto:</b> ${currentConcepto}<br><b>A√±o:</b> ${currentYear}<br><b>Incidencia:</b> ${value.toLocaleString()} carpetas`;
                            } else {
                                popupContent += `<br><br><i>No hay datos disponibles para "${currentConcepto}" en ${currentYear}</i>`;
                            }
                        } else {
                            popupContent += `<br><br><i>Selecciona un concepto y a√±o para ver datos</i>`;
                        }
                        
                        layer.bindPopup(popupContent);
                        
                        estadosActualizados++;
                    } else {
                        console.log(`   ‚ö†Ô∏è ${entidad}: No hay datos para ${concepto} en ${year}`);
                    }
                }
            });
            
            console.log(`‚úÖ Estados actualizados: ${estadosActualizados}`);
        }
        
        // Funci√≥n para crear el mapa de estados
        function createEstadosMap() {
            try {

                
                // Verificar que el contenedor existe
                const mapContainer = document.getElementById('map');
                if (!mapContainer) {
                    console.error('‚ùå No se encontr√≥ el contenedor del mapa');
                    return;
                }
                
                // Crear el mapa centrado en M√©xico (sin capa base)
                map = L.map('map', {
                    center: [23.6345, -102.5528],
                    zoom: 5,
                    zoomControl: true,
                    attributionControl: false
                });
                
                // Establecer l√≠mites del mapa para que no se pueda alejar demasiado
                map.setMaxBounds([14.5, -118.5, 32.5, -86.5]); // L√≠mites de M√©xico
                
                // Cargar GeoJSON de estados
                fetch('data/geojson/estados.json')
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        return response.json();
                    })
                    .then(geojsonData => {
                        // Agregar estados al mapa
                        const estadosLayer = L.geoJSON(geojsonData, {
                            style: function(feature) {
                                return {
                                    fillColor: '#3498db',
                                    weight: 1.5,
                                    opacity: 1,
                                    color: '#2c3e50',
                                    fillOpacity: 0.8
                                };
                            },
                            onEachFeature: function(feature, layer) {
                                // Mostrar nombre del estado en popup
                                const nombre = feature.properties.NOMGEO || 'Estado';
                                
                                // Crear popup con datos si est√°n disponibles
                                let popupContent = `<b>${nombre}</b>`;
                                
                                if (entidadConceptoData && currentConcepto && currentYear) {
                                    const entidadData = entidadConceptoData[nombre];
                                    if (entidadData && entidadData[currentConcepto] && entidadData[currentConcepto][currentYear]) {
                                        const value = entidadData[currentConcepto][currentYear];
                                        popupContent += `<br><br><b>Concepto:</b> ${currentConcepto}<br><b>A√±o:</b> ${currentYear}<br><b>Incidencia:</b> ${value.toLocaleString()} carpetas`;
                                    } else {
                                        popupContent += `<br><br><i>No hay datos disponibles para "${currentConcepto}" en ${currentYear}</i>`;
                                    }
                                } else {
                                    popupContent += `<br><br><i>Selecciona un concepto y a√±o para ver datos</i>`;
                                }
                                
                                layer.bindPopup(popupContent);
                            }
                        });
                        
                        estadosLayer.addTo(map);
                        
                        // Ajustar la vista del mapa para mostrar todos los estados
                        if (estadosLayer.getBounds) {
                            const bounds = estadosLayer.getBounds();
                            map.fitBounds(bounds, { padding: [20, 20] });
                        }
                        
                        // Forzar redibujado del mapa
                        map.invalidateSize();
                        
                        // Ocultar el mensaje de carga
                        const mapContainer = document.getElementById('map');
                        if (mapContainer) {
                            mapContainer.classList.add('loaded');
                        }
                    })
                    .catch(error => {
                        console.error('‚ùå Error cargando GeoJSON:', error);
                        mapContainer.innerHTML = '<p style="text-align: center; color: #d32f2f; padding: 20px;">Error cargando el mapa</p>';
                    });
                
            } catch (error) {
                console.error('‚ùå Error creando mapa:', error);
            }
        }

    </script>
    
    <!-- Leaflet JavaScript para mapas -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
</body>
</html>
